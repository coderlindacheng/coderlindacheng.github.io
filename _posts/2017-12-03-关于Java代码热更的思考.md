---
title: 关于Java代码热加载的思考
category: java
tags: [mark]
no-post-nav: true
---

关于Java代码热加载的一些个人总结

## JAVA虚拟机的内存模型
  ![JAVA虚拟机的内存模型](/assets/images/java内存模型.png)
  
  如图看到的是java虚拟机的内存模型,类加载关系到的内存区域是在静态方法区,所以类一单加载进来,就一定要full gc的时候才能被回收了

## 内建的类加载器

### 启动类加载器(BootstrapClassLoader)
启动类加载器主要加载的是JVM自身需要的类,这个类加载使用C++语言实现的,是虚拟机自身的一部分,它负责将 <JAVA_HOME>/lib路径下的核心类库或-Xbootclasspath参数指定的路径下的jar包加载到内存中,注意必由于虚拟机是按照文件名识别加载jar包的,如rt.jar,如果文件名不被虚拟机识别,即使把jar包丢到lib目录下也是没有作用的(出于安全考虑,Bootstrap启动类加载器只加载包名为java、javax、sun等开头的类).

### 扩展类加载器(ExtClassLoader)
扩展类加载器是指Sun公司(已被Oracle收购)实现的sun.misc.Launcher$ExtClassLoader类,由Java语言实现的,是Launcher的静态内部类,它负责加载<JAVA_HOME>/lib/ext目录下或者由系统变量-Djava.ext.dir指定位路径中的类库，开发者可以直接使用标准扩展类加载器.

### 系统类加载器(AppClassLoader)
也称应用程序加载器是指 Sun公司实现的sun.misc.Launcher$AppClassLoader.它负责加载系统类路径java -classpath或-D java.class.path 指定路径下的类库，也就是我们经常用到的classpath路径,开发者可以直接使用系统类加载器,一般情况下该类加载是程序中默认的类加载器,通过ClassLoader#getSystemClassLoader()方法可以获取到该类加载器.

## 类的卸载条件

该类所有的实例都已经被回收，也就是java堆中不存在该类的任何实例。
加载该类的ClassLoader已经被回收。
该类对应的java.lang.Class对象没有任何地方被引用，无法在任何地方通过反射访问该类的方法。

## 风险

1. 如果热加载进来的类包的class对象或者实例对象被非热加载的类包一直引用就会导致类卸载失败，然后程序长时间运行下去就会有可能导致静态区的内存溢出

2. 如果classloader一直被持有，没被垃圾回收，也会出现1的情况，所以最好别让它活过一个方法的区域，就是new出来了，创建完了需要的类就立即抛弃它

## 可行办法

1. 热加载的内容，最后只会有一个引用被非热加载的实例持有，classloader在加载完立刻抛弃，这样，在卸载类的时候，只要置换被持有的引用实例就可以了，毫无风险

2. 只让热加载的jar包的类调用非热加载的内容，而且不要让热加载的jar包所产生的实例在非热加载的jar包的实例中持续存活，但热加载的jar的实例持续持有非热加载的jar的实例是允许的，因为一旦热加载的类被卸载了，被持有的非热加载的类实例也会被卸载，但是前提是加载和卸载都是以一个整体来进行，意思就是，例如：一加载就加载一整个jar一卸载就卸载一整个jar

3. 热加载的包，只含有无状态的类，这也是可行的. 所谓无状态，就一个类是只做计算，中间没有任何属性，（存在属性就意味着存在状态）.简单来说，就是所有的方法都只是函数

4. 无论是1和2，方法的返回值都是非热加载的类型

## 总结

最后，其实热加载的实例存活在非热加载的实例中也是可以的，只是这样做，程序会变得很乱，很不好管理.

**设计只要遵循一个原则：干净，低耦合**

要不然，自己搞的垃圾，自己都收拾不干净
